---
import Case from "../components/CaseCard.svelte";
import type { TypeProjectCase } from "../types/TypeCase";
const { cases } = Astro.props;
const isSingleRow = cases.length <= 2; // Если кейсов 2 или меньше, будет один ряд
const numRows = isSingleRow ? 1 : 2;
const caseColumns = Math.ceil(cases.length / numRows);
---

<div class="portfolio-cases container" data-component="cases-slider">
    <h2 class="portfolio-cases__title">Кейсы</h2>
    <div class="portfolio-cases__slider-wrapper">
        <div class:list={["carusel", { "single-row": isSingleRow }]}>
            {
                cases.map((c: TypeProjectCase) => (
                    <Case
                        client:only
                        metadata={c.metadata}
                        content={c.htmlContent}
                    />
                ))
            }
        </div>
        {
            !isSingleRow && (
                <button class="btn-back" aria-label="back"></button>
                <button class="btn-next" aria-label="next"></button>
            )
        }
        
    </div>
    {
        !isSingleRow && (
            <div class="portfolio-cases__dots">
                {Array(caseColumns)
                    .fill(null)
                    .map((_, index) => (
                        <button
                            class="dot"
                            data-index={index}
                            aria-label={`Перейти к слайду ${index + 1}`}
                        />
                    ))}
            </div>
        )
    }

    <div class="portfolio-cases__last-statement container">
        Портфолио дополняется. Следите за обновлениями!
    </div>
</div>

<style lang="scss">
    @use "../styles/h2-title" as *;

    @keyframes gradient-shift {
        0% {
            background-position: 0% 50%;
        }
        100% {
            background-position: 100% 50%;
        }
    }

    .portfolio-cases {
        scroll-margin-top: 10vw;

        &__title {
            @include title-h2;
            text-align: left;
        }

        &__slider-wrapper {
            position: relative;
            display: flex;
            align-items: center;
            gap: 0.5em;
        }

        &__dots {
            display: flex;
            justify-content: center;
            gap: 0.5em;
            padding: 1em;

            .dot {
                width: 1em;
                height: 1em;
                background-color: rgba(255, 255, 255, 0.1);
                border-radius: 50%;
                cursor: pointer;
                border: none;
                transition:
                    background-color 500ms ease-in-out,
                    scale 1000ms ease-in-out;
                position: relative;
                scale: 1.3;

                &.active {
                    background-color: var(--color-azure);
                    scale: 1;
                }

                &::after {
                    content: "";
                    position: absolute;
                    inset: 0;
                    border-radius: 50%;
                    background-color: rgba(255, 255, 255, 0.1);
                    opacity: 0;
                    transition: opacity 300ms ease-in-out;
                }

                &:hover::after {
                    opacity: 1;
                }
            }
        }
    }

    .carusel {
        overflow-x: scroll;
        scroll-snap-type: x mandatory;
        scroll-behavior: smooth;
        display: grid;
        grid-auto-flow: column;
        grid-template-rows: repeat(2, 1fr);
        flex-grow: 1;
        gap: 1em;
        padding-bottom: 1em;

        -ms-overflow-style: none; /* IE and Edge */
        scrollbar-width: none; /* Firefox */
        &::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        &.single-row {
            grid-template-rows: 1fr;
        }
    }

    $btn_radius: 2.5em;

    .btn-back,
    .btn-next {
        background-color: transparent;
        color: var(--color-basic-white, #fff);
        position: absolute;
        border: none;
        top: 50%;
        transform: translateY(-50%);
        min-width: $btn_radius;
        min-height: $btn_radius;
        transform-origin: center center;

        cursor: pointer;
        font-size: 1.5em;
        border-radius: 50%;
        z-index: 10;
        flex-shrink: 0;
        transition:
            background-color 300ms ease-in-out,
            opacity 300ms ease-in-out;
        opacity: 0;

        * {
            color: red;
        }

        &::after {
            content: "";
            position: absolute;
            background-image: url("data:image/svg+xml,%3Csvg width='240' height='440' viewBox='0 0 240 440' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M9.88357 430.108C22.9006 443.125 44.0072 443.125 57.0239 430.108L219.937 267.032C245.951 240.995 245.941 198.802 219.917 172.775L56.9039 9.763C43.8872 -3.25433 22.7806 -3.25433 9.76325 9.763C-3.25442 22.7807 -3.25442 43.886 9.76325 56.9037L149.284 196.425C162.304 209.442 162.304 230.548 149.284 243.565L9.88357 382.968C-3.13409 395.985 -3.13409 417.088 9.88357 430.108Z' fill='%23f0f0f0'/%3E%3C/svg%3E");
            background-repeat: no-repeat no-repeat;
            background-position: center center;
            background-size: 50% 50%;
            inset: 0;
        }

        &:hover {
            background-color: rgba(255, 255, 255, 0.1);
            opacity: 1 !important;
        }

        @media (max-width: 1450px) {
            & {
                display: none;
            }
        }
    }

    .btn-back {
        left: ($btn_radius + 0.5em) * (-1);

        &::after {
            rotate: 180deg;
        }
    }

    .btn-next {
        right: ($btn_radius + 0.5em) * (-1);
    }

    .portfolio-cases__slider-wrapper:hover :is(.btn-back, .btn-next) {
        opacity: 0.3;
    }

    .portfolio-cases__last-statement {
        color: var(--color-basic-white-80);
        font-size: 0.8em;
        font-weight: 600;

        margin-bottom: 4em * 1.2;
        padding-top: 2em;
        text-align: center;

        background: linear-gradient(
            90deg,
            #ff0084,
            /* Цвет A */ #e91e63,
            /* Цвет B */ #00bcd4,
            /* Цвет C */ #4caf50,
            /* Цвет D */ #ff0084
        );
        background-size: 400% 100%;

        color: transparent;

        -webkit-background-clip: text;
        background-clip: text;

        animation: gradient-shift 10s ease infinite alternate;
    }

    @media (max-width: 600px) {
        .portfolio-cases__slider-wrapper {
            gap: 0.2em;
        }
        .btn-back,
        .btn-next {
            padding: 0.5em 0.8em;
            font-size: 1.2em;
        }
        // .carusel {
        //     grid-template-rows: 1fr;
        // }
    }
</style>

<script>
    document.addEventListener("DOMContentLoaded", () => {
        document
            .querySelectorAll("[data-component='cases-slider']")
            .forEach((slider) => {
                const carusel = slider.querySelector(".carusel");
                const btnNext = slider.querySelector(".btn-next");
                const btnBack = slider.querySelector(".btn-back");
                const dots = slider.querySelectorAll(".dot");

                if (!(carusel instanceof HTMLElement) || !btnNext || !btnBack) {
                    return;
                }

                const waitForFirstCard = setInterval(() => {
                    const firstCard = carusel.querySelector(".case-item");
                    if (firstCard) {
                        clearInterval(waitForFirstCard); // Останавливаем проверку
                        initSlider(); // Запускаем слайдер
                    }
                }, 100); // Проверяем каждые 100мс

                const initSlider = () => {
                    let scrollAmount = 0;
                    function updateScrollAmount() {
                        const firstCard = carusel?.querySelector(".case-item");
                        if (firstCard instanceof HTMLElement && carusel) {
                            const cardWidth = firstCard.offsetWidth;
                            const gap = parseFloat(
                                getComputedStyle(carusel).gap || "0px"
                            );
                            scrollAmount = cardWidth + gap;
                            console.log(scrollAmount);
                        } else {
                            scrollAmount = 350;
                        }
                    }

                    updateScrollAmount(); // Первоначальный расчет

                    if (scrollAmount === 0) return;

                    let resizeTimer: ReturnType<typeof setTimeout>;
                    window.addEventListener("resize", () => {
                        clearTimeout(resizeTimer);
                        resizeTimer = setTimeout(updateScrollAmount, 250); // Пересчет с задержкой после окончания ресайза
                    });

                    dots.forEach((dot, index) => {
                        dot.addEventListener("click", () => {
                            const targetCard = carusel.querySelector(
                                `[data-col-index="${index}"]`
                            );
                            if (targetCard instanceof HTMLElement) {
                                const offsetLeft = targetCard.offsetLeft;
                                carusel.scrollTo({
                                    left: offsetLeft,
                                    behavior: "smooth",
                                });
                            } else {
                                carusel.scrollTo({
                                    left: index * scrollAmount,
                                    behavior: "smooth",
                                });
                            }
                        });
                    });

                    btnNext.addEventListener("click", () => {
                        const maxScrollLeft =
                            carusel.scrollWidth - carusel.clientWidth;
                        if (carusel.scrollLeft >= maxScrollLeft - 1) return;

                        const currentPageIndex = Math.round(
                            carusel.scrollLeft / scrollAmount
                        );
                        carusel.scrollTo({
                            left: (currentPageIndex + 1) * scrollAmount,
                            behavior: "smooth",
                        });
                    });

                    btnBack.addEventListener("click", () => {
                        if (carusel.scrollLeft <= 0) return;
                        const currentPageIndex = Math.round(
                            carusel.scrollLeft / scrollAmount
                        );
                        carusel.scrollTo({
                            left: (currentPageIndex - 1) * scrollAmount,
                            behavior: "smooth",
                        });
                    });

                    // Логика подсветки точек
                    const intersectionObserver = new IntersectionObserver(
                        (entries) => {
                            entries.forEach((entry) => {
                                const colIndex =
                                    entry.target.getAttribute("data-col-index");
                                if (colIndex) {
                                    const dot = slider.querySelector(
                                        `.dot[data-index="${colIndex}"]`
                                    );
                                    if (dot) {
                                        dot.classList.toggle(
                                            "active",
                                            entry.isIntersecting
                                        );
                                    }
                                }
                            });
                        },
                        { root: carusel, threshold: 0.8 }
                    );

                    const cards = carusel.querySelectorAll(".case-item");
                    const numRows = carusel.classList.contains("single-row")
                        ? 1
                        : 2;
                    cards.forEach((card, i) => {
                        const colIndex = Math.floor(i / numRows);
                        card.setAttribute(
                            "data-col-index",
                            colIndex.toString()
                        );
                        if (i % numRows === 0) {
                            intersectionObserver.observe(card);
                        }
                    });
                };
            });
    });
</script>
